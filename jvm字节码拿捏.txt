定义:	java二级进制字节码运行环境
优点与功能:
	一次编写,到处运行
	自动内存管理,垃圾回收功能
	数组下表越界检查
	多态
比较:
jvm与jre与jdk

javaee程序(JDK+应用服务器+IDE工具)::javase程序(JDK+IDE工具)::JDK(JVM+基础类库+编译工具)::JRE(JVM+基础类库)::JVM


伪代码:
class
classloader
struct jvmobject{

method area:T,
Heap:H,
JVM stacks: Jstack<T,R>，
PC Register:(&int),//记录下一条虚拟机指令的执行地址{而非当前的IP地址,读取寄存器}
Native Method Stack：Nstack<T,R>.
}
mod 执行引擎{
	mod I解释器{},
	mod JIT即时编译器{},
	mod GC垃圾回收{},
}

mod native imp native(N navive:&N)-> mod native{

}
impl PCReg_thread(&jvmobject)->&PC{
	let mut PC= PC;

	PC+=len；
	return PC;

}

impl JVM_stacks_thread(&jvmobject)->*JVM stacks{
	thread_start=allloc(stck)
	stack_帧= mod start need allloc(stack_帧);
	stack(参数,局部变量,返回地址)

	stck::push(stack_帧)
	-Xss size分配栈大小
	GC只回收堆内存
	栈越大线程越少

}

二进制字节码:
	0:getstatic #20


1.解释器从程序计数器获取指令地址解释java二进制字节码为机械码
2.CPU执行机械码



jvm PC特点:
线程私有寄存器
不存在内存溢出


_____________________________________________________________________\\\\
我们写的应用
Spring,Struts,Mybatis,SpringMVC
Java API
JVM

高级语言
汇编语言
机械指令
CPU
{架构师:系统更快,系统瓶颈}
java自动管理内存动态分配,垃圾回收



―――――――――――――――
java程序
字节码文件
win/jvm linux/jvm  mac/jvm
――――――――――――――-
JVM:负责硬件与操作系统独立性,保证字节码文件,保护用户不受恶意代码攻击.
JVM是跨语言平台

――――――|
不同语言	   
|
各自编译器
|(编译)
字节码文件[遵循Java规范]
|
JVM
――――――|
_________________________

CPU 编译器 操作系统

加载器:装载到子系统

共享:方法区,堆
线程私有:java栈，native方法栈,程序计数器

执行引擎 本地调用接口
JNI
前端编译器:词法分析，语法分析，语法抽象树，语义分析，注解抽象语法树，字节码生成器
(翻译字节码)解释执行
(JIT即时编译)编译执行[热点代码]{二次编译}

基于栈的指令架构
	设计实现更简单,适用于资源受限的系统
	避开寄存器分配难题,使用零地址指令分配
	指令集更小
	不需要硬件支持，可以执行性更好
基于寄存器的指令架构
	例如传统PC以及davlik虚拟机
	指令架构完全依赖硬件
	性能优秀,执行更高效
	花费更少指令完成一项操作
JVM基于栈:
	跨平台,指令集小,指令多:性能比寄存器差。
JVM生命周期:
	虚拟机的启动:
		通过引导类加载器加载创建一个初始类(initial class),这个类是由虚拟机的具体实现指定的。
	虚拟机执行:
		task:执行java程序
		程序运行时执行,程序终止时终止
		本质是执行一个jvm进程
JDK1.4:
	引擎只有一个解释器能够工作
Exact VM(准确内存管理):
	虚拟机可以直到内存中某个位置的数据具体是什么类型
	热点探测
	编译器与解释器混合工作
	只在solaris平台使用
HotSpot VM:
	热点代码探测技术
	通过计数器找到最具编译价值的代码,触发及时编译或栈上替换
	增加了方法区概念,编译器解释器同时工作,在最优化程序响应时间与最佳执行性能中取得平衡

JRookit VM:
	专注于服务端
	不包含解释器,全部代码靠及时编译后执行
	是最快的JVM虚拟机
	客户体验硬件成本减少
	Jrokit面向延迟敏感型应用的解决方案,毫秒微妙级别,适合财务,军事指挥,电信电网
	missioncontrol服务套件(JMC监控)监控管理分析生产环境的应用程序工具（监视内存泄漏）

IBM的J9:
	定位于Hotspot接近,服务器端,桌面应用,嵌入式多用途.
	高性能最快在IBM产品中

KVM和CDC/CLDC:
	java me产品线
	KVM简单，轻量，高度可移植性
		智能控制器传感器
		老人手机,经济欠发达地区手机
	原则:一次编译到处运行

Azul VM:
	高性能虚拟机,与特定硬件平台绑定,软硬件配合
	可管理数十个CPU和数百GB内存,巨大内存范围实现可控GC
Liquid VM：
	无需操作系统支持,自身实现了线程调度,文件系统,网络支持.

Apache Harmony：
	由IBM和Intel联合开发,其类库被归入了Android SDK。
	非JCP规范
Microsoft JVM:
	java Applets

Taobao JVM:
	基于openjdk定制了自己的AlibabaJDK。
	创新的GCIH技术实现了off-heap,生命周期较长的放到heap外,能够在多个虚拟机共享对象
	硬件依赖intel的CPU损失了兼容性


Dalvik VM：
	谷歌开发，
	不能直接执行class
	基于寄存器架构而不是jvm栈架构
	执行的是dex文件(由class转化来)
	Androde 5.0支持提前编译(AOT)的ART VM 替换了Dalvik VM.


Graal VM:
	运行任何程序更快
	跨语言全栈虚拟机,可作为任何语言的运行平台
	支持混用接口
	提供truffle工具集快速构建面向一种新语言的解释器,运行时进行及时编译优化获得更高效率.



[类加载子系统]


Class Loader
Loading 		Linking 		Intailzation
引导类		验证
扩展类		准备
系统类		解析

负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识
classloader只负责class文件加载,是否可以运行由Execution Engine决定
类信息存放在方法区的内存空间。方法区还包含运行时常量池信息,或者字符串字面量和数字常量.（内存映射）
class文件->JVM->DNA元数据模板
内存中调用构造器构造实例

加载:
	1.通过类的全限定名获取此类的二进制字节流
	2.将这个字节流所代表的静态存储结构,转化为方法区的运行时数据结构
	3.在内存中生成一个代表这个类的java.lang.Class对象[实例],作为方法区这个类的各种数据的访问数据
	方式:
		本地系统
		网络获取
		zip包读取
		运行时计算生成:动态代理技术
		其他文件生成:JSP应用
		从专有数据库提取
		从加密文件获取

链接:
	验证(Verify):保证二进制安全
	准备(Prepare):变量prepare为0，随后初始化,不会为实例变量初始化
	解析(Resolve):常量池的符号引用转为直接引用(目标指针，相对偏移量)
	主要针对类和接口字段类方法接口方法,方法类型等
初始化:{静态代码块在这一步}
	执行类构造器方法<clinit>()的过程;
	此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
	构造器方法中指令按语句在原文件中出现的顺序执行。
	<clinit>()不同于类的构造器.(关联:构造器是虚拟机视角下的<init>())
	若该类具有父类,JVM会保证子类的<clinit>()执行前父类的<clinit>()已经执行完毕
	虚拟机必须保证一个类的<clinit>() 方法在多线程下被同步加锁.


两类加载器:引导类加载器,自定义类加载器
扩展类加载器,系统类加载器

启动类加载器:
	运用C/C++语言实现嵌套在JVM内部，
	来自JAVA核心类库.
	并不继承自 ClassLoader
	加载扩展类应用程序类加载器,指定它们为上一层
	出于安全考虑Bootstrap启动类质保函java javax sun开头的类

扩展类加载器:
	Java语言编编写
	派生于启动类加载器
	从JDK的jre/lib/ext子目录下加载类库
	java.ext.dirs	

应用程序加载器:
	java编写
	派生于启动类加载器
	程序的默认加载器
	java.class属性指定目录


用户自定义类加载器:
	隔离加载类(可以理解成容器或者共享资源或者数据耦合处理)
	修改类加载的方式(默认核心API,引入确定的API)
	扩展加载源(数据库等数据字节代码的来源)
	防止源码泄露(加密与解密)

	[步骤]
		1.继承java.lang.ClassLoader
		2.重写findClass
		3.无需复杂需求可以继承URLClassLoader。
双亲委派机制:
	一个类加载器收到了类加载器它自己不加载,会先委托给其父类加载器,
	如果还有其父类,依次递归,如果父类可以加载(即位于自己的加载目录下)
	[如果加载失败]则加载完成,否则向下委托.
	优势:
		避免类的重复加载
		保护程序安全防止核心API被篡改.
			java.lang.*
	沙箱安全机制
在JVM中表示两个class对象是否是同一个类的必要条件:
	类的完整类名包名已知
	加载这个类的ClassLoader必须相同.
JVM必须知道一个类型是由启动加载器加载的还是由用户加载器加载的
解析一个类型到另一个类型的引用的时候两个类型是统一ClassLoad
Java对类的主动使用:
	创建类的实例
	访问类与接口的静态变量
	调用静态方法
	初始化一个类的子类
	动态语言支持
被动使用:会加载,但不一定初始化

[运行时数据区]
	class文件-Load link initialize->class Loader-run>[]->GC
	内存是CPU和硬盘的中间仓库以及桥梁.
	申请分配管理策略
	{进程'a}堆外空间{95%}(jdk1.8元空间),堆{5%}
	{线程'b}程序计数器,栈,本地栈

	java每个线程都对应操作系统的每个本地线程.
	守护线程,普通线程
	[后台线程]:jconsole查看
		虚拟机线程：
		周期任务线程:
		GC线程:
		编译线程:
		信号调度线程:
	[PC寄存器]
		对物理PC寄存机的一种抽象模拟(PC计数器或者程序钩子)
	
	栈是运行时单位
	堆是存储单位
	栈内保存一个个栈帧,对应一次次Java方法.
	作用:保存方法局部变量(对象的引用地址,8种基本数据类型),部分结果,并参与方法的调用和返回.
	快速有效的分配存储方式,访问速度仅次于程序计数器
	栈不存在垃圾回收问题(不存在GC)
	每个线程都有自己的VMS栈中数据以栈帧的格式存在
	一个方法对应一个栈帧
	栈帧是一个内存块,是一个数据集,维系着方法执行过程中的各种数据信息
	类的基本结构:field(属性,字段,域),method
	一个时间点只允许一个活动栈帧
	[局部变量表LVT]
		定义为一个数组,主要用于方法参数和定义在方法体的局部变量
		不存在数据安全问题
		局部变量所需的容量大小在编译时期确认
		locals=3方法内局部变量表的大小
		方法销毁局部变量表也销毁
		最基本存储单元是Slot(变量槽)
		32位以内的类型只占用一个slot(包括returnAddress)64位 占用两个slot.
		局部变量：使用前必须进行显示赋值
		局部变量表中的变量垃圾回收根节点,被直接间接引用的对象都不会被删除
	[操作数栈]
		保存计算过程的中间结果,这份方法的操作数栈默认是空的
	解释引擎的操作站是操作数栈
	栈顶缓存技术(ToS,Top-of-Stack Cashing)将栈顶元素全部缓存在物理CPU的寄存器,以此降低对内存的读写次数,提升执行引擎的执行效率.
	[附加信息+动态链接+方法返回地址]=帧数据区[保存了访问常量池的引用指针]
	[动态链接]{运行期间}:[静态解析]{编译期间}
	[早期绑定]{确定结构不变}:[晚期绑定]{运行期确定方法}
	解析时所有用到的变量方法类全部都在常量池进行(#)声明。可进行符号引用->直接引用
	面向过程只有早期绑定.
	JAVA中的任何普通方法都类似于虚函数.

	非虚方法:静态方法,私有方法,final方法,实例构造器,父类方法,都是非虚方法.
	其他方法称为虚方法.
	
	子类对象的多态特性的使用前提:1.类的继承关系，2.方法的重写
	普通指令:
		invokestatic：调用静态方法解析阶段确定唯一方法版本
		invokespecial: 调用<init>方法，私有以及父类方法解析阶段确定

		invokevirtual：调用所有虚方法
		invokeinterface：调用所有接口方法
		
	动态调用指令
		invokedynamic：动态解析出方法(Java最初借助ASM底层字节码工具来产生动态指令，直到JAVA8出现Lamda表达式{函数式接口}Java才可以实现字节码)
	静态语言是判断自身的类型信息,动态类型语言是判断变量值的类型信息,变量本身没有类型信息。
	从实际变量类型向上查找栈顶类型为C。
	为了提高性能,建立虚方法表(VMT),查找类型.
	每个类都有一个虚方法表表中存在方法实际入口
	
	[方法返回地址]:
		保存PC寄存器的值作为返回地址给解析引擎。
		异常推出则通过异常表。
		正常完成出口:i/b/l/f/d/a|return
		异常处理表采用字节偏移地址
	[一些附加信息]:
	[局部变量表+操作数栈+方法返回地址+动态链接]+PC

	方法区生命周期最长{最长与JVM一样}
	堆生命周期短期

	共享不考虑同步会存在线程安全
	
	{Rust语言}内部产生内部消亡是安全的
		内部产生返回外部是不安全的
	

	[本地方法接口]
		一个native  method方法是一个java调用非java代码的接口
		C语言可通过extern "C"告诉C++去编译一个C语言函数
		abstruct除外
		与Java环境外的交互是本地方法存在的原因。
	Java实现了jre与底层系统的交互
	JAVA没有规定必须使用本地方法栈
	
类的加载器   class文件结构     执行引擎
	   内存结构
	   内存分配与回收
	   性能监控(命令行,可视化工具)
	   性能优化
	
	[heep_堆]-Xms初始堆空间 or -Xmx最大堆空间
		堆是JAVA管理内存的核心区域
		JAVA堆区在JVM启动时就被创建,其空间大小也就被确定了,是JVM管理的最大一块内存空间.
		堆可以是物理空间上不连续的内存空间中,逻辑上它可以是连续的。
		所有线程共享JAVA堆,这里还可以划分线程私有缓冲区(TLAB).
	所有对象实例以及数组都应在运行时分配在堆上。
	方法结束后堆中对象不会马上被移除全部由GC回收
	栈,堆,方法区(Simple堆类及其方法的具体实现).
	JAVA8:[新生区=[E+S1+S2]+养老区=分配堆空间]+元空间
	-XX -PrintGCDetaile
	Runtime.getRuntime().totalXXX()[.maxXXX()使用最大值]统计空间单元获得运行环境
	
	默认堆空间大小:
		初始内存大小:物理电脑内存/64
		最大内存大小:物理电脑内存大小/4
		
	查看参数:jps/jstat -gc pid
	
开发中的异常:
	JAVA栈允许设置固定值或是不变的
	oom?
	sof?





翻译为机械码	操作局部变量表,操作数栈
	| 	|	[JVM栈]
	{执行引擎}		[当前方法]
	[PC寄存器]_____|-----[局部变量表]
			[操作数栈](表达式栈)
			[动态链接](指向常量池的方法引用)
			[方法返回地址](方法正常推出或者异常推出的定义)
			[附加信息]
       (指向native则是未定义地址) []
(唯一一个没有
OutOtMemoryError
,GC)


	
常量池
类元数据
方法元数据

瞬时对象,创建消亡过快放在年轻代
生命周期很长放在老年代

Eden{新生对象}
Surviver0[From]{幸存者区}
Surviver1[to]{幸存者区}
-XX:NewRatio=2 新生代永远占1 老年代占2新生代占堆空间的1/3{设置新生代与老年代比例}
堆空间默认比例1:2
默认堆空间是600MB
-XX:SurvivorRatio调整空间比例


YGC/Minor GC
每个对象都有一个age计数器
STW(回收算法)

YGC最大15达到老年代
Eden满了触发YGC,被动回收S0
S0满了不会触发YGC

JAVA优化:
	jprofiler

Partial GC
	Minor GC/Yong GC 只是新生代的垃圾收集
	Minor GC/Old GC 只是针对老年代的垃圾收集
	Mjor GC和Full GC 混淆使用需要具体分辨老年代回收还是整堆回收
	混合收集(Mixed GC)
Full GC
	收集整个java堆和方法区的垃圾收集
	老年代空间不足触发
	方法区空间不足触发
	尽量避免FUllGC
	System.gc()强制回收

当年轻代空间不足触发Minor GC,主要指Eden
Eden优先
长期存活优先
大对象分配到老年代
动态对象年龄判断
空间分配担保

TLAB(Thread Local Allocation Buffer)
堆区是线程共享区.任何线程都可以访问到堆的共享区
并发环境线程不安全
为避免多个线程操作同一个地址

从内存模型来看,分配在Eden区


老年区的连续堆空间大于新生代对象则进行Minjor GC
降低STW时间

随着JIT的发展和逃逸分析技术成熟，栈上分配，标量分配。
一个对象并没有逃逸出一个方法，那么就可能被优化成栈上分配。

方法在外部被引用称之为逃逸

方法在外部没有被引用称之为没有发生逃逸


JDK7之后逃逸分析开启

SOAP 方法指的是遵守 SOAP 编码规则的 HTTP 请求/响应。
HTTP + XML = SOAP

SOAP 请求可能是 HTTP POST 或 HTTP GET 请求。

HTTP POST 请求规定至少两个 HTTP 头：Content-Type 和 Content-Length。

栈上分配:JIT根据逃逸分析结果进行栈上分配


同步省略:如果对象只有一个线程访问,消去锁。
分离对象或标量替换:无法分解的数据就是标量,可分解的叫聚合量。有的对象内存不连续,可存储在CPU上。
{服务器端-Server开启逃逸分析.}对象打散成标量
GCIH

.class 	{方法区}   {Java栈}     {方法区}
	[Person] [person]  = [new Person()]

#-XX:PermSize
	已经不能使用
-XX:MaxMetaspaceSize
	的值是-1

[Method Area]
类型信息=>运行时常量池=>静态变量=>JIT代码缓存=>域信息=>方法信息

域信息(Field):
JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
域的相关信息包括:域名称,域类型,域修饰符(public,private,protected,static,final,volatile,transient的某个子集)

方法信息(Method):
方法名称
方法的返回类型(或void)
方法的修饰符
方法的字节码,操作数栈,局部变量表大小(abstract和native方法)
异常表(adstract和native方法除外)
每个异常处理的开始位置,结束位置,代码处理在程序计数器中的偏移地址,被捕获的异常类的常量池索引.
java 虚拟机参数可以是XML格式
手写JVM需要:
类加载器和执行引擎

final在编译时就已经确认

方法区内部包含了运行时常量池
字节码文件,内部包含了类的常量池
[cafebaby][minnor|_version][major|_version]
常量池:以字面量方式呈现
运行时常量池:
加载类和接口到虚拟机后就会创建对应的运行时常量池
JVM会为每个类类型加载一个运行时常量池。
具备动态性与符号表类似

jdk1.6在永久代静态变量存放在永久带上
jdk1.7有永久代但是已经逐渐出现了去永久代
jdk1.8无永久代,有元空间(),但字符串常量池,静态变量仍然在堆上.	

一个与堆不相连的本地内存区域,这个区域叫做元空间(Metaspace)
为永久代设置空间大小是很难确定的

可以不要求在方法区实现GC

编译原理:字面量和符号引用
判断一个类不被使用的三个条件：
	类的所有实例被回收包括其子类
	加载该类的类的加载器已经被回收，除非第精心设计的可替换类加载器比如OSGI,JSP等重载，否则很难回收
	该类的Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法
	
-Xnoclassgc参数进行控制
-verbose:class以及-XX:+TraceClass-Loading,-XX:+TraceClassUnLoading查看累的加载卸载信息
在大量使用反射,动态代理,CGLib等字节码框架动态生成JSP以及OSGi这类偏饭自定义加载器的场景中.


[对象的实例化]
创建方式:
	new:-Xxx的静态方法
	       -XxxBuilder/XxxFactory的静态方法

	反射:
		Class的newInstance();反射方式只能调用空参的构造器,权限必须是public
		Constructor的newInstance(xx):反射方式可以调用空参和有参的构造器无权限要求
	使用clone():
		不用调用任何构造器,当前类需要实现Cloneable接口实现clone()
	使用反序列化:
		从文件中网络中获取一个对象的二进制流
	第三方库：Object库
创建步骤:
	1.判断对象对应的类是否加载,链接,初始化**加载类元信息
	2.为对象分配内存:**为对象分配内存
			如果内存规整--指针碰撞
			如果内存不规整-虚拟维护一个列表
				      --空闲列表分配
			GC是否采用标记整理或者标记压缩算法采用的内存策略

	3.处理并发安全问题:**处理并发问题
			cas失败重试(),区域加载保证更新原子性
			每个线程分配一块TLAB-通过-XX:+UseTLAB调试参数
	4.初始化分配空间:**0值初始化
	5.设置对象头:具体方式通过JVM参数设置,指向类元信息**设置对象头信息
	6.执行init方法**属性的显示初始化:属性的默认初始化->显示初始化/代码块中的初始化->构造器中的初始化

实例数据:
对象头:
	[元数据]
	[类型指针]
	实例数据:
		字符串常量池

对象的访问:
栈帧->堆
          |(元数据指针)
           方法区
[对象头]


句柄访问
直接指针

来源于NIO,通过存在在堆中的Directer
	如果是数组还需要记录数组长度
[Instance Data]
	相同宽度的字段分配在一起
	首先存放原始类
	如果是CompactFiled
[对其填充]













当前版本:hotspot虚拟机		